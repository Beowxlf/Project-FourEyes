`If you know how malware reaches the kernel, you'll know how to cut the phone line`

> [!NOTE] Objective
> Today we will learn about:
> - What a system call (syscall) actually is
> - How user-mode apps invoke kernal functions
> - The System Service Dispatch Table (SSDT)
> - How malware and EDRs use hooking, stomping, or bypassing of syscalls
> - How to detect abnormal syscall behavior in modern Windows systems

## Explain Like I Am 12
`Imagine you are a guest at a hotel. You want room service (open file, create process, allocate memory). You cannot go to the kitchen yourself -> you must call the front desk and they page the chef`
- In this case:
	- User-mode app = the guest
	- Syscall = the phone call to front desk
	- Kernel-mode function = the chef
	- Syscall table = list of phone numbers for each service
- Syscalls are the only legal way to access kernal power from user-mode. If a guest breaks into the kitchen? That's an exploit.

---
## Windows Syscall Mechanics

#### Process:
- App calls a Windows API like CreateFile()
- That wraps to a Native API:
	- `NtCreateFile()`
	- `in ntdll.dll`
- Native API makes a syscall instruction (usually syscall or int 0x2e)
- CPU switches to Ring 0, looks up the Syscall Number in the SSDT
- Kernel executes corresponding function inside `ntsokrnl.exe`
## System Service Dispatch Table (SSDT)

| Thing          | Purpose                                                     |
| -------------- | ----------------------------------------------------------- |
| SSDT           | Table mapping syscall numbers > function pointers in kernal |
| Syscall Number | Each native function has a unique ID                        |
| ntoskrnl.exe   | Implements kernel-mode service routines                     |
| ntdll.dll      | Provides syscall stubs in userland                          |
Windows Defender, Crowd strike, and others intercept these at this boundary to block or monitor suspicious calls.

---
## Attacker Tradecraft

| Technique                | Purpose                                                 |
| ------------------------ | ------------------------------------------------------- |
| Syscall Hooking          | Overwrite syscall address to point to custom code       |
| SSDT Patching            | Modify the syscall table (Ring 0 only - rootkit level)  |
| Direct Syscalls          | Bypass ntdll.dll > inject syscall stub manually         |
| Syscall Stomping         | Overwrite ntdll.dll with randow/clean bytes > EDR fails |
| heavens Gate (x86 > x64) | Anuse WoW64 subsystem to bypass x64 hooks               |
## Example: Direct Syscall Shellcode (Red Team)
```
mov r10, rcx 
mov eax, 0x123 ; syscall ID for NtOpenProcess
syscall
ret
```
- This bypasses userland EDR hooks entirely. Unless you catch it at ETW or kernel, you'll miss it.

---
## Detection Methods (And Why Most Fail)

| Method               | Weakness                                                       |
| -------------------- | -------------------------------------------------------------- |
| Sysmon Event ID 1    | Misses low-level syscall abuse                                 |
| EDR userland hooking | Bypassed by syscall stompong or manual syscalls                |
| ETW                  | Reliable if hooked before attacker disables it                 |
| Kernel Mode drivers  | Hardest to bypass but also hardest to build                    |
| Memory Scans         | Can detect overwritten ntdll.dll or injected syscall shellcode |
## Tools For Research

| Tool           | Use                                                  |
| -------------- | ---------------------------------------------------- |
| PE-sieve       | Detect overwritten syscall stubs                     |
| SysWhispers2   | Generate syscall shellcode for red team use          |
| Process Hacker | Check memory of loaded ntdll.dll or detect tampering |
| WinDbg         | Trace real syscalls (!syscall, !ssdt, etc)           |
| HookExplorer   | View function hooks in memory (experimental)         |
## Blue Team Application
`If you do not understand how attackers make direct requests to the kernel, you'll be blind to advanced threats.`
- SIGMA rules alone won't help --> **you need telemety from the syscall layer** (ex. ETW, Defender's kernel-mode driver)
- Real detections come from:
	- Unexpected syscall numbers in legit processes
	- Missing or malformed ntdll.dll
	- Driver loads that patch SSDT or disable ETW